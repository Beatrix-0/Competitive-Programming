# Calculate Subtree Size , Child count and Leaf node for each node

## DFS

```cpp
#include<bits/stdc++.h>
using namespace std ;

const int mx = 1e3+12;
vector<int> g[mx];
int subtree_size[mx];
int child_count[mx];
bool isLeaf[mx];

void dfs( int u , int p ){
    subtree_size[u] = 1 ;
    child_count[u] = 0 ;
    for ( auto v : g[u]){
        if ( v == p ) continue;
        dfs(v , u);
        subtree_size[u] += subtree_size[v];
        child_count[u]++;
    }
    if (child_count[u] == 0 ){
        isLeaf[u] = true;
    }
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int n ; cin >> n ;
    for ( int i = 0 ; i < n-1 ; i++ ){
        int u , v ;
        cin >> u >> v ;
        g[u].push_back(v);
        g[v].push_back(u);
    }

    int root = 1; // assume root
    dfs(root , -1);

    // for ( int i = 1 ; i <= n ; i++ ){
    //     cout << subtree_size[i] << " " << child_count[i] << '\n';
    // }

    return 0 ;
}
```

## BFS

```cpp
#include<bits/stdc++.h>
using namespace std ;

const int mx = 1e3+12;
vector<int> g[mx];
int subtree_size[mx];
int child_count[mx];
bool isLeaf[mx];

void bfs( int root , int n ){
    queue<int>q;
    vector<bool>vis(mx , false);
    vector <int>order;

    vis[root] = true;
    q.push(root);
    vector<int> parent(mx, -1);

    while (!q.empty()){
        int u = q.front(); q.pop();
        order.push_back(u);
        for ( auto v : g[u]){
            if (!vis[v]){
                vis[v] = true;
                parent[v] = u;
                q.push(v);
            }
        }
    }

    // process in reverse order( bottom to top like recursive call)
    for ( int i = n-1 ; i >= 0 ; i-- ){
        int u = order[i];
        subtree_size[u] = 1 ;
        child_count[u] = 0 ;

        for ( auto v : g[u]){
            if ( v != parent[u]){
                subtree_size[u] += subtree_size[v];
                child_count[u]++;
            }
        }
        if ( child_count[u] == 0 ){
            isLeaf[u] = true;
        }
    }


}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int n ; cin >> n ;
    for ( int i = 0 ; i <n-1 ; i++ ){
        int u , v ;
        cin >> u >> v ;
        g[u].push_back(v);
        g[v].push_back(u);
    }

    int root = 1; // assume root
    bfs(root , n );

    for ( int i = 1 ; i<= n ; i++ ){
        cout << subtree_size[i] << " " << child_count[i] << '\n';
    }

    return 0 ;
}
```

<!-- 7
1 2
1 3
2 4
2 5
3 6
3 7 -->
