## Subtree Queries (Sum, Min, Max, Count)
We can store answers for subtrees in a single DFS.
```cpp
vector<int> g[100005];
int val[100005], subtree_sum[100005];

void dfs(int u, int p){
    subtree_sum[u] = val[u];
    for(auto v : g[u]){
        if(v == p) continue;
        dfs(v, u);
        subtree_sum[u] += subtree_sum[v];
    }
}
```

## Path Sum (Node to Root)
We can calculate prefix sums from the root to each node.
```cpp
int path_sum[N];
void dfs(int u, int p){
    path_sum[u] = val[u] + (p ? path_sum[p] : 0);
    for(auto v : g[u]){
        if(v == p) continue;
        dfs(v, u);
    }
}
```

## Counting in Subtrees
Count number of even-valued nodes in each subtree.
```cpp
int cnt_even[N];
void dfs(int u, int p){
    cnt_even[u] = (val[u] % 2 == 0);
    for(auto v : g[u]){
        if(v == p) continue;
        dfs(v, u);
        cnt_even[u] += cnt_even[v];
    }
}
```

## Distance Sum from Root
For each node, find distance from the root.
```cpp
int dist[N];
void dfs(int u, int p){
    for(auto v : g[u]){
        if(v == p) continue;
        dist[v] = dist[u] + 1;
        dfs(v, u);
    }
}
```

## Classic Problem: “Maximum Subtree Sum”
**Problem**:
Each node has a value (can be negative).
Find the maximum sum of any connected subtree.

**Intuition**: Similar to maximum subarray sum (Kadane’s) but on a tree.
```cpp
int ans = -1e9;
int dfs(int u, int p){
    int curr = val[u];
    for(auto v : g[u]){
        if(v == p) continue;
        curr += max(0, dfs(v, u)); // only take positive subtree contributions
    }
    ans = max(ans, curr);
    return curr;
}
```