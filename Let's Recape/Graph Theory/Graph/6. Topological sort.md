## Top sort using dfs

Problem : [Course Schedule](https://cses.fi/problemset/task/1679)

```cpp
#include <bits/stdc++.h> //O(V+E)
using namespace std;

#ifndef ONLINE_JUDGE
#include "trace.cpp"
#else
#define dbg(...)
#endif

const int mx = 1e5+12;
vector<int> g[mx];
bool vis[mx];
vector<int>ord;

void dfs( int u){
    vis[u] = true;
    for ( auto v : g[u]){
        if (!vis[v]){
            dfs(v);
        }
    }
    ord.push_back(u);
}

void solve() {
    int n , m ;
    cin >> n >> m ;
    for ( int i = 0 ; i < m ; i++ ){
        int u , v ;
        cin >> u >> v ;
        g[u].push_back(v);
    }

    for ( int u = 1 ; u <= n ; u++ ){
        if ( !vis[u]){
            dfs(u);
        }
    }
    reverse(ord.begin() , ord.end());
    vector<int>pos(n+1);
    for ( int i = 0 ; i < ord.size() ; i++){
        pos[ord[i]] = i;
    }

    bool ok = true;
    for ( int u = 1 ; u <= n ; u++ ){
        for( auto v : g[u]){
            if ( pos[u] >= pos[v]){
                ok = false;
                break;
            }
        }
        if(!ok) break;
    }
    if(ok){
        for ( auto it : ord){
            cout << it << " ";
        }
        cout << '\n';
    }
    else {
        cout << "IMPOSSIBLE" << '\n';
    }
}

int32_t main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int tests = 1;
    // cin >> tests;
    for ( int tc = 1 ; tc <= tests ; tc++ ){
        solve();
    }
    return 0;
}
```

## Top sort using queue(Kahn's Algorithm)

Problem : [Course Schedule](https://cses.fi/problemset/task/1679) </br>
[Video Tutorial](https://youtu.be/cIBFEhD77b4?si=xdIl1FI0gSKM2YNU)

```cpp
#include <bits/stdc++.h> //O(V+E)
using namespace std;

#ifndef ONLINE_JUDGE
#include "trace.cpp"
#else
#define dbg(...)
#endif

const int mx = 1e5+12;
vector<int>g[mx];
int indeg[mx];

void solve() {
    int n , m ;
    cin >> n >> m ;
    for ( int i = 0 ; i < m ; i++ ){
        int u , v ;
        cin >> u >> v ;
        g[u].push_back(v);
        indeg[v]++;
    }
    queue<int>q;
    for ( int i = 1 ; i <= n ; i++ ){
        if ( indeg[i] == 0 ){
            q.push(i);
        }
    }
    vector<int>ord;
    while(!q.empty()){
        int u = q.front();
        q.pop();
        ord.push_back(u);
        for ( auto v : g[u]){
            --indeg[v];
            if ( indeg[v] == 0 ){
                q.push(v);
            }
        }
    }

    if ( ord.size() != n ){ // cycle detected
        cout << "IMPOSSIBLE" << '\n';
    }
    else{
        for (auto it : ord ){
            cout << it << " ";
        }
    }
}

int32_t main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int tests = 1;
    // cin >> tests;
    for ( int tc = 1 ; tc <= tests ; tc++ ){
        solve();
    }
    return 0;
}
```

## Top sort code

```cpp
#include<bits/stdc++.h> // Complexity O(V+E)
using namespace std ;

const int N = 1e5;
vector < int > g(N);
bool vis[N];
int indeg[N];

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int n , m ;
    cin>> n >> m ;
    while ( m-- ){
        int u , v ;
        cin>> u >> v ;
        indeg[v]++;
        g[u].push_back(v);
    }
    vector < int > z ;
    for ( int i = 1 ; i <= n ; i++ ){
        if ( indeg[i] == 0 ){
            z.push_back(i);
            vis[i] = true ;
        }
    }
    bool ok = true ;
    vector < int >ord ;
    while ( ord.size() < n ){
        if ( z.empty()){
            cout << "IMPOSSIBLE" << '\n';
            return 0 ;
        }
        int cur = z.back();
        z.pop_back();
        ord.push_back(cur);
        for ( auto v : g[cur]){
            indeg[v]--;
            if ( !vis[v] && deg[v] == 0 ){
                z.push_back(v);
                vis[v] = true ;
            }
        }
        for ( auto it : ord ){
            cout << it << " ";
        }
        cout << '\n';
    }
    return 0 ;
}
```
